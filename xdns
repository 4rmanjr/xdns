#!/bin/bash

# ==============================================================================
# xdns - Advanced Linux DNS Changer (v3.0 Hardened)
# Informatif, Interaktif, Aman, dan Atomic.
# ==============================================================================

# --- Configuration & Constants ---
RESOLV_CONF="/etc/resolv.conf"
BACKUP_DIR="/var/backups/xdns"
BACKUP_CONTENT="$BACKUP_DIR/resolv.conf.orig"
BACKUP_LINK_TARGET="$BACKUP_DIR/resolv.conf.link_path"
TMP_SORT="/tmp/xdns_latency_test"
VERSION="3.0.0"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# --- DNS Providers ---
declare -A DNS_NAMES
declare -A DNS_IPS

DNS_NAMES[1]="Google DNS (Standard)"
DNS_IPS[1]="8.8.8.8 8.8.4.4"

DNS_NAMES[2]="Cloudflare (Fast & Private)"
DNS_IPS[2]="1.1.1.1 1.0.0.1"

DNS_NAMES[3]="Cloudflare (Malware Block)"
DNS_IPS[3]="1.1.1.2 1.0.0.2"

DNS_NAMES[4]="Quad9 (Security & Privacy)"
DNS_IPS[4]="9.9.9.9 149.112.112.112"

DNS_NAMES[5]="AdGuard (Ad Blocking)"
DNS_IPS[5]="94.140.14.14 94.140.15.15"

DNS_NAMES[6]="OpenDNS (Home)"
DNS_IPS[6]="208.67.222.222 208.67.220.220"

DNS_NAMES[7]="Verisign (Stability)"
DNS_IPS[7]="64.6.64.6 64.6.65.6"

# --- Safety & Traps ---

# Cleanup on exit or interrupt
cleanup() {
    rm -f "$TMP_SORT"
}
trap "cleanup; echo -e '\n${YELLOW}[!] Script dihentikan.${NC}'; exit 0" SIGINT SIGTERM

function check_root() {
    if [[ $EUID -ne 0 ]]; then
       echo -e "${RED}[!] Error: Akses Root diperlukan.${NC}" 
       echo "    Jalankan: sudo xdns"
       exit 1
    fi
}

function check_dependencies() {
    local REQUIRED=("bc" "ping" "chattr" "lsattr" "readlink")
    local MISSING=()
    
    for cmd in "${REQUIRED[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            MISSING+=("$cmd")
        fi
    done

    if [ ${#MISSING[@]} -ne 0 ]; then
        echo -e "${RED}[!] Dependency Kurang:${NC} ${MISSING[*]}"
        echo -e "${YELLOW}[i] Silakan install paket tersebut via package manager Anda.${NC}"
        exit 1
    fi
}

# --- Core Logic ---

function header() {
    clear
    echo -e "${CYAN}${BOLD}"
    echo "█   █  ████   █   █   ████"
    echo " █ █   █   █  ██  █  █    "
    echo "  █    █   █  █ █ █   ███ "
    echo " █ █   █   █  █  ██      █"
    echo "█   █  ████   █   █  ████ "
    echo -e "${NC}"
    echo -e "${BLUE}:: Universal DNS Manager v${VERSION} ::${NC}"
    echo -e "----------------------------------------"
    echo -e "${YELLOW}WARNING: Gunakan menu Restore jika ingin login WiFi Publik (Hotel/Cafe)${NC}"
    echo -e "         atau saat menggunakan VPN Kantor (Split DNS).${NC}"
    echo -e "----------------------------------------"
}

function get_current_dns() {
    echo -e "${YELLOW}[i] DNS Saat Ini:${NC}"
    if [ -f "$RESOLV_CONF" ]; then
        if [ -L "$RESOLV_CONF" ]; then
             local TARGET=$(readlink -f "$RESOLV_CONF")
             echo -e "    ${CYAN}(Symlink ke: $TARGET)${NC}"
        fi
        
        grep "nameserver" "$RESOLV_CONF" 2>/dev/null | head -n 3 | awk '{print "    ➜ " $2}'
        
        if lsattr "$RESOLV_CONF" 2>/dev/null | grep -q "i"; then
             echo -e "${RED}    (LOCKED / IMMUTABLE)${NC}"
        fi
    else
        echo -e "${RED}    Tidak dapat membaca $RESOLV_CONF${NC}"
    fi
    echo ""
}

function init_backup() {
    # HANYA Backup jika belum pernah dibackup sebelumnya (Golden Image)
    if [ ! -d "$BACKUP_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
    fi

    if [ ! -f "$BACKUP_CONTENT" ]; then
        echo -e "${YELLOW}[i] Membuat backup original sistem...${NC}"
        
        # 1. Simpan Konten (jaga-jaga)
        cp -L "$RESOLV_CONF" "$BACKUP_CONTENT"
        
        # 2. Simpan Target Symlink (jika ada)
        if [ -L "$RESOLV_CONF" ]; then
            readlink "$RESOLV_CONF" > "$BACKUP_LINK_TARGET"
        fi
    fi
}

function unlock_file() {
    # Check support for chattr first to avoid error noise on some filesystems
    if lsattr "$RESOLV_CONF" &>/dev/null; then
        if lsattr "$RESOLV_CONF" 2>/dev/null | grep -q "i"; then
            chattr -i "$RESOLV_CONF" > /dev/null 2>&1
        fi
    fi
}

function lock_file() {
    chattr +i "$RESOLV_CONF" > /dev/null 2>&1
    if lsattr "$RESOLV_CONF" 2>/dev/null | grep -q "i"; then
        echo -e "${GREEN}[✓] File DNS dikunci (Immutable).${NC}"
    else
        echo -e "${RED}[!] Gagal mengunci file (Filesystem tidak mendukung chattr?)${NC}"
    fi
}

function send_notification() {
    local TITLE="$1"
    local MESSAGE="$2"
    
    # Only send if run via sudo and notify-send exists
    if [ -n "$SUDO_USER" ] && command -v notify-send &> /dev/null; then
        local USER_ID=$(id -u "$SUDO_USER")
        # Modern Linux (systemd) puts the bus at /run/user/<uid>/bus
        local BUS_ADDR="unix:path=/run/user/$USER_ID/bus"
        
        # Fallback for older systems or custom setups might be needed, 
        # but this covers 99% of Fedora/Ubuntu/Arch usage.
        
        sudo -u "$SUDO_USER" DBUS_SESSION_BUS_ADDRESS="$BUS_ADDR" \
        notify-send -a "xdns" -u normal -i network-wired "$TITLE" "$MESSAGE" 2>/dev/null
    fi
}

function reload_network_manager() {
    # Tell NetworkManager to reload so it notices the change (if not locked)
    # or at least stops complaining in logs.
    if command -v nmcli &> /dev/null; then
        nmcli general reload conf 2>/dev/null
    fi
}

function flush_dns_cache() {
    local FLUSHED=false
    # Silent attempts
    if command -v resolvectl &> /dev/null; then
        resolvectl flush-caches >/dev/null 2>&1 && FLUSHED=true
    elif command -v systemd-resolve &> /dev/null; then
        systemd-resolve --flush-caches >/dev/null 2>&1 && FLUSHED=true
    fi
    if command -v nscd &> /dev/null; then
        nscd -i hosts >/dev/null 2>&1 && FLUSHED=true
    fi
    if pgrep dnsmasq > /dev/null; then
        killall -HUP dnsmasq >/dev/null 2>&1 && FLUSHED=true
    fi

    if [ "$FLUSHED" = true ]; then
        echo -e "${GREEN}[✓] Cache DNS dibersihkan.${NC}"
    fi
}

function restore_dns() {
    echo -e "${YELLOW}[*] Memulihkan konfigurasi original...${NC}"
    unlock_file
    
    if [ -f "$BACKUP_LINK_TARGET" ]; then
        # Restore as Symlink
        local TARGET=$(cat "$BACKUP_LINK_TARGET")
        echo -e "${CYAN}[i] Mengembalikan symlink ke $TARGET...${NC}"
        ln -sf "$TARGET" "$RESOLV_CONF"
    elif [ -f "$BACKUP_CONTENT" ]; then
        # Restore as Static File
        echo -e "${CYAN}[i] Mengembalikan isi file static...${NC}"
        cat "$BACKUP_CONTENT" > "$RESOLV_CONF"
    else
        echo -e "${RED}[!] Backup tidak ditemukan! Tidak bisa restore.${NC}"
        read -p "Tekan Enter..." 
        return
    fi
    
    flush_dns_cache
    reload_network_manager
    send_notification "DNS Restored" "System configuration has been restored."
    echo -e "${GREEN}[✓] Restore selesai. Sistem kembali seperti semula.${NC}"
    read -p "Tekan Enter untuk kembali..."
}

function test_latency() {
    echo -e "${YELLOW}[*] Benchmark DNS (Ping Test)...${NC}"
    echo "------------------------------------------------"
    printf "${BOLD}%-25s %-15s %-10s${NC}\n" "Provider" "IP" "Latency"
    echo "------------------------------------------------"

    # Ensure clean start
    rm -f "$TMP_SORT"
    
    for i in "${!DNS_IPS[@]}"; do
        IP=$(echo "${DNS_IPS[$i]}" | awk '{print $1}')
        NAME="${DNS_NAMES[$i]}"
        
        # Ping check
        AVG_PING=$(ping -c 2 -W 1 "$IP" 2>/dev/null | tail -1 | awk -F '/' '{print $5}')
        [[ -z "$AVG_PING" ]] && AVG_PING="999"
        
        echo "$AVG_PING|$NAME|$IP" >> "$TMP_SORT"
    done

    sort -n -t '|' -k1 "$TMP_SORT" | while IFS='|' read time name ip; do
        if [[ "$time" == "999" ]]; then
            TIME_DISPLAY="${RED}Down${NC}"
        else
            if (( $(echo "$time < 30" | bc -l) )); then COLOR=$GREEN
            elif (( $(echo "$time < 100" | bc -l) )); then COLOR=$YELLOW
            else COLOR=$RED
            fi
            TIME_DISPLAY="${COLOR}${time} ms${NC}"
        fi
        printf "%s\n" "%s %s %s" "$name" "$ip" "$TIME_DISPLAY"
    done
    
    rm -f "$TMP_SORT"
    echo "------------------------------------------------"
    read -p "Tekan Enter untuk kembali..."
}

function apply_dns() {
    local PRIMARY=$1
    local SECONDARY=$2
    local NAME=$3

    # --- Pre-Flight Check ---
    echo -e "${YELLOW}[*] Cek koneksi ke $PRIMARY...${NC}"
    if ! ping -c 1 -W 2 "$PRIMARY" &> /dev/null; then
        echo -e "${RED}[!] Koneksi Gagal! Server DNS tidak merespon.${NC}"
        echo -e "    Batalkan perubahan demi keamanan.${NC}"
        sleep 2
        return
    fi

    # --- Execution ---
    echo -e "${YELLOW}[*] Menerapkan ${NAME}...${NC}"
    
    init_backup # Ensure we have the original backup ONCE
    unlock_file

    # Atomic Write Strategy: Write to temp, then move
    local TMP_CONF="/tmp/resolv.conf.new"
    echo -e "# Generated by xdns v${VERSION} on $(date)\n# Provider: ${NAME}" > "$TMP_CONF"
    echo "nameserver $PRIMARY" >> "$TMP_CONF"
    [[ -n "$SECONDARY" ]] && echo "nameserver $SECONDARY" >> "$TMP_CONF"

    # Move with force to overwrite/break symlink safely
    mv -f "$TMP_CONF" "$RESOLV_CONF"

    # Fix SELinux Context (Fedora/RHEL/CentOS)
    if command -v restorecon &> /dev/null; then
        restorecon "$RESOLV_CONF"
    fi

    echo -e "${GREEN}[✓] DNS Aktif!${NC}"
    flush_dns_cache
    reload_network_manager
    send_notification "DNS Changed" "Provider: $NAME\nPrimary: $PRIMARY"

    echo ""
    echo -e "${CYAN}Kunci DNS ini (Immutable)?${NC}"
    read -p "Pilihan (y/n): " LOCK_CHOICE
    if [[ "$LOCK_CHOICE" =~ ^[Yy]$ ]]; then
        lock_file
    fi

    read -p "Tekan Enter..."
}

function set_custom_dns() {
    echo -e "${YELLOW}[*] Set Custom DNS${NC}"
    read -p "Primary IP   : " C_PRIM
    read -p "Secondary IP : " C_SEC
    
    # Strict IP Regex
    local IP_REGEX="^([0-9]{1,3}\.){3}[0-9]{1,3}$"
    
    if [[ ! $C_PRIM =~ $IP_REGEX ]]; then
        echo -e "${RED}[!] Format IP tidak valid.${NC}"
        sleep 2
        return
    fi
    
    apply_dns "$C_PRIM" "$C_SEC" "Custom DNS"
}

# --- Main Loop ---

check_root
check_dependencies
init_backup # Cek backup saat startup

while true; do
    header
    get_current_dns

    echo -e "${BOLD}Pilih Provider:${NC}"
    for i in $(echo "${!DNS_NAMES[@]}" | tr ' ' '\n' | sort -n); do
        echo -e "  ${BOLD}$i.${NC} ${DNS_NAMES[$i]}"
    done
    echo ""
    echo -e "  ${BOLD}C.${NC} Custom DNS"
    echo -e "  ${BOLD}T.${NC} Speed Test"
    echo -e "  ${BOLD}R.${NC} Restore Original"
    echo -e "  ${BOLD}Q.${NC} Keluar"
    echo ""
    read -p ">> " CHOICE

    case $CHOICE in
        [1-9])
             [[ -n "${DNS_NAMES[$CHOICE]}" ]] && \
             IPS=${DNS_IPS[$CHOICE]} && \
             apply_dns $(echo $IPS | awk '{print $1}') $(echo $IPS | awk '{print $2}') "${DNS_NAMES[$CHOICE]}"
            ;;
        [cC]*) set_custom_dns ;; 
        [tT]*) test_latency ;; 
        [rR]*) restore_dns ;; 
        [qQ]*) echo -e "${GREEN}Bye!${NC}"; exit 0 ;; 
        *) echo -e "${RED}Invalid.${NC}"; sleep 1 ;; 
    esac
done
