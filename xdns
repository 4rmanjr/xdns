#!/bin/bash
# ==============================================================================
# xdns - Advanced Linux DNS Changer (v3.1.0 Production)
# Informatif, Interaktif, Aman, dan Atomic.
# ==============================================================================

# --- Strict Mode (partial - without -e for interactive) ---
set -uo pipefail

# --- Exit Codes ---
readonly EXIT_SUCCESS=0
readonly EXIT_ERROR=1
readonly EXIT_NOT_ROOT=2
readonly EXIT_MISSING_DEPS=3
readonly EXIT_NETWORK_ERROR=4

# --- Configuration & Constants ---
readonly RESOLV_CONF="/etc/resolv.conf"
readonly BACKUP_DIR="/var/backups/xdns"
readonly BACKUP_CONTENT="$BACKUP_DIR/resolv.conf.orig"
readonly BACKUP_LINK_TARGET="$BACKUP_DIR/resolv.conf.link_path"
readonly VERSION="3.1.0"

# Runtime variables
TMP_SORT=""  # Will be set securely via mktemp

# --- Colors ---
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# --- DNS Providers ---
declare -A DNS_NAMES
declare -A DNS_IPS

DNS_NAMES[1]="Google DNS (Standard)"
DNS_IPS[1]="8.8.8.8 8.8.4.4"

DNS_NAMES[2]="Cloudflare (Fast & Private)"
DNS_IPS[2]="1.1.1.1 1.0.0.1"

DNS_NAMES[3]="Cloudflare (Malware Block)"
DNS_IPS[3]="1.1.1.2 1.0.0.2"

DNS_NAMES[4]="Quad9 (Security & Privacy)"
DNS_IPS[4]="9.9.9.9 149.112.112.112"

DNS_NAMES[5]="AdGuard (Ad Blocking)"
DNS_IPS[5]="94.140.14.14 94.140.15.15"

DNS_NAMES[6]="OpenDNS (Home)"
DNS_IPS[6]="208.67.222.222 208.67.220.220"

DNS_NAMES[7]="Verisign (Stability)"
DNS_IPS[7]="64.6.64.6 64.6.65.6"

# ==============================================================================
# LOGGING FUNCTIONS
# ==============================================================================

log_info() {
    echo -e "${YELLOW}[i]${NC} $*"
}

log_ok() {
    echo -e "${GREEN}[✓]${NC} $*"
}

log_error() {
    echo -e "${RED}[!]${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}[!]${NC} $*"
}

log_step() {
    echo -e "${YELLOW}[*]${NC} $*"
}

# ==============================================================================
# SAFETY & TRAPS
# ==============================================================================

# Cleanup on exit or interrupt
cleanup() {
    [[ -n "${TMP_SORT:-}" && -f "${TMP_SORT:-}" ]] && rm -f "$TMP_SORT"
}

# Safe exit handler - ensure we don't leave partial state
safe_exit() {
    local exit_code=$?
    cleanup
    if [[ $exit_code -ne 0 ]]; then
        echo -e "\n${YELLOW}[!] Script dihentikan.${NC}"
    fi
    exit $exit_code
}
trap safe_exit EXIT
trap 'exit 130' SIGINT SIGTERM

# ==============================================================================
# VALIDATION FUNCTIONS
# ==============================================================================

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "Akses Root diperlukan."
        echo "    Jalankan: sudo xdns"
        exit $EXIT_NOT_ROOT
    fi
}

check_dependencies() {
    local required=("bc" "ping" "chattr" "lsattr" "readlink" "mktemp")
    local missing=()
    
    for cmd in "${required[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing+=("$cmd")
        fi
    done

    if [[ ${#missing[@]} -ne 0 ]]; then
        log_error "Dependency Kurang: ${missing[*]}"
        log_info "Silakan install paket tersebut via package manager Anda."
        exit $EXIT_MISSING_DEPS
    fi
}

# Validate IPv4 address - returns 0 if valid, 1 if invalid
validate_ipv4() {
    local ip="$1"
    local IFS='.'
    local -a octets
    
    # Must match basic IPv4 pattern first
    if [[ ! "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        return 1
    fi
    
    read -ra octets <<< "$ip"
    
    # Must have exactly 4 octets
    [[ ${#octets[@]} -ne 4 ]] && return 1
    
    # Each octet must be 0-255
    for octet in "${octets[@]}"; do
        # Remove leading zeros for comparison (10# forces base-10)
        octet=$((10#$octet))
        if (( octet < 0 || octet > 255 )); then
            return 1
        fi
    done
    
    return 0
}

# ==============================================================================
# HELP & VERSION
# ==============================================================================

show_help() {
    cat << EOF
${BOLD}xdns${NC} v${VERSION} - Advanced Linux DNS Manager

${BOLD}USAGE:${NC}
    sudo xdns [OPTIONS]

${BOLD}OPTIONS:${NC}
    -h, --help      Show this help message
    -v, --version   Show version information
    -l, --list      List available DNS providers
    -s, --set N     Set DNS provider by number (1-7)
    -c, --custom    Set custom DNS (interactive)
    -r, --restore   Restore original DNS configuration
    -t, --test      Run DNS latency benchmark

${BOLD}EXAMPLES:${NC}
    sudo xdns              # Interactive mode
    sudo xdns -s 2         # Set Cloudflare DNS
    sudo xdns -s 1 --lock  # Set Google DNS and lock
    sudo xdns -r           # Restore original
    sudo xdns -t           # Run speed test

${BOLD}DNS PROVIDERS:${NC}
    1. Google DNS          8.8.8.8, 8.8.4.4
    2. Cloudflare          1.1.1.1, 1.0.0.1
    3. Cloudflare Secure   1.1.1.2, 1.0.0.2
    4. Quad9               9.9.9.9, 149.112.112.112
    5. AdGuard             94.140.14.14, 94.140.15.15
    6. OpenDNS             208.67.222.222, 208.67.220.220
    7. Verisign            64.6.64.6, 64.6.65.6

${BOLD}NOTES:${NC}
    - Use --restore before connecting to captive portals (hotel/cafe WiFi)
    - VPN users with split DNS should avoid locking DNS

${BOLD}MORE INFO:${NC}
    https://github.com/4rmanjr/xdns

EOF
}

show_version() {
    echo "xdns version ${VERSION}"
    echo "Advanced Linux DNS Manager"
    echo "License: MIT"
}

list_providers() {
    echo -e "${BOLD}Available DNS Providers:${NC}"
    echo ""
    for i in $(echo "${!DNS_NAMES[@]}" | tr ' ' '\n' | sort -n); do
        local ips="${DNS_IPS[$i]}"
        printf "  %s. %-25s %s\n" "$i" "${DNS_NAMES[$i]}" "$ips"
    done
    echo ""
}

# ==============================================================================
# CORE LOGIC
# ==============================================================================

show_header() {
    clear
    echo -e "${CYAN}${BOLD}"
    echo "█   █  ████   █   █   ████"
    echo " █ █   █   █  ██  █  █    "
    echo "  █    █   █  █ █ █   ███ "
    echo " █ █   █   █  █  ██      █"
    echo "█   █  ████   █   █  ████ "
    echo -e "${NC}"
    echo -e "${BLUE}:: Universal DNS Manager v${VERSION} ::${NC}"
    echo -e "----------------------------------------"
    echo -e "${YELLOW}WARNING: Gunakan menu Restore jika ingin login WiFi Publik (Hotel/Cafe)${NC}"
    echo -e "         atau saat menggunakan VPN Kantor (Split DNS).${NC}"
    echo -e "----------------------------------------"
}

get_current_dns() {
    log_info "DNS Saat Ini:"
    if [[ -f "$RESOLV_CONF" ]]; then
        if [[ -L "$RESOLV_CONF" ]]; then
            local target
            target=$(readlink -f "$RESOLV_CONF")
            echo -e "    ${CYAN}(Symlink ke: $target)${NC}"
        fi
        
        grep "nameserver" "$RESOLV_CONF" 2>/dev/null | head -n 3 | awk '{print "    ➜ " $2}'
        
        if lsattr "$RESOLV_CONF" 2>/dev/null | grep -q "i"; then
            echo -e "${RED}    (LOCKED / IMMUTABLE)${NC}"
        fi
    else
        log_error "Tidak dapat membaca $RESOLV_CONF"
    fi
    echo ""
}

init_backup() {
    # HANYA Backup jika belum pernah dibackup sebelumnya (Golden Image)
    if [[ ! -d "$BACKUP_DIR" ]]; then
        if ! mkdir -p "$BACKUP_DIR"; then
            log_error "Gagal membuat direktori backup: $BACKUP_DIR"
            return 1
        fi
    fi

    if [[ ! -f "$BACKUP_CONTENT" ]]; then
        log_info "Membuat backup original sistem..."
        
        # 1. Simpan Konten
        if ! cp -L "$RESOLV_CONF" "$BACKUP_CONTENT" 2>/dev/null; then
            log_warn "Tidak dapat backup isi file (mungkin tidak ada)"
        fi
        
        # 2. Simpan Target Symlink (jika ada)
        if [[ -L "$RESOLV_CONF" ]]; then
            readlink "$RESOLV_CONF" > "$BACKUP_LINK_TARGET"
        fi
    fi
}

unlock_file() {
    # Check support for chattr first to avoid error noise on some filesystems
    if lsattr "$RESOLV_CONF" &>/dev/null; then
        if lsattr "$RESOLV_CONF" 2>/dev/null | grep -q "i"; then
            chattr -i "$RESOLV_CONF" > /dev/null 2>&1
        fi
    fi
}

lock_file() {
    chattr +i "$RESOLV_CONF" > /dev/null 2>&1
    if lsattr "$RESOLV_CONF" 2>/dev/null | grep -q "i"; then
        log_ok "File DNS dikunci (Immutable)."
    else
        log_error "Gagal mengunci file (Filesystem tidak mendukung chattr?)"
    fi
}

send_notification() {
    local title="$1"
    local message="$2"
    
    # Only send if run via sudo and notify-send exists
    if [[ -n "${SUDO_USER:-}" ]] && command -v notify-send &> /dev/null; then
        local user_id
        user_id=$(id -u "$SUDO_USER")
        # Modern Linux (systemd) puts the bus at /run/user/<uid>/bus
        local bus_addr="unix:path=/run/user/$user_id/bus"
        
        sudo -u "$SUDO_USER" DBUS_SESSION_BUS_ADDRESS="$bus_addr" \
            notify-send -a "xdns" -u normal -i network-wired "$title" "$message" 2>/dev/null || true
    fi
}

reload_network_manager() {
    # Tell NetworkManager to reload so it notices the change
    if command -v nmcli &> /dev/null; then
        nmcli general reload conf 2>/dev/null || true
    fi
}

flush_dns_cache() {
    local flushed=false
    
    # Silent attempts - try all known methods
    if command -v resolvectl &> /dev/null; then
        resolvectl flush-caches >/dev/null 2>&1 && flushed=true
    elif command -v systemd-resolve &> /dev/null; then
        systemd-resolve --flush-caches >/dev/null 2>&1 && flushed=true
    fi
    
    if command -v nscd &> /dev/null; then
        nscd -i hosts >/dev/null 2>&1 && flushed=true
    fi
    
    if pgrep dnsmasq > /dev/null 2>&1; then
        killall -HUP dnsmasq >/dev/null 2>&1 && flushed=true
    fi

    if [[ "$flushed" == true ]]; then
        log_ok "Cache DNS dibersihkan."
    fi
}

restore_dns() {
    log_step "Memulihkan konfigurasi original..."
    unlock_file
    
    if [[ -f "$BACKUP_LINK_TARGET" ]]; then
        # Restore as Symlink - validate target first
        local target
        target=$(head -n1 "$BACKUP_LINK_TARGET" 2>/dev/null | tr -d '[:space:]')
        
        # Validate symlink target is a reasonable path
        if [[ -z "$target" || ! "$target" =~ ^/[a-zA-Z0-9/_.-]+$ ]]; then
            log_error "Backup symlink target tidak valid atau corrupt!"
            read -rp "Tekan Enter..." 
            return 1
        fi
        
        echo -e "    ${CYAN}Mengembalikan symlink ke $target...${NC}"
        if ! ln -sf "$target" "$RESOLV_CONF"; then
            log_error "Gagal membuat symlink!"
            read -rp "Tekan Enter..." 
            return 1
        fi
    elif [[ -f "$BACKUP_CONTENT" ]]; then
        # Restore as Static File
        echo -e "    ${CYAN}Mengembalikan isi file static...${NC}"
        if ! cat "$BACKUP_CONTENT" > "$RESOLV_CONF"; then
            log_error "Gagal menulis ke $RESOLV_CONF!"
            read -rp "Tekan Enter..." 
            return 1
        fi
    else
        log_error "Backup tidak ditemukan! Tidak bisa restore."
        read -rp "Tekan Enter..." 
        return 1
    fi
    
    flush_dns_cache
    reload_network_manager
    send_notification "DNS Restored" "System configuration has been restored."
    log_ok "Restore selesai. Sistem kembali seperti semula."
    read -rp "Tekan Enter untuk kembali..."
}

test_latency() {
    log_step "Benchmark DNS (Ping Test)..."
    echo "------------------------------------------------"
    printf "${BOLD}%-25s %-15s %-10s${NC}\n" "Provider" "IP" "Latency"
    echo "------------------------------------------------"

    # Create secure temp file
    TMP_SORT=$(mktemp /tmp/xdns_latency.XXXXXX) || {
        log_error "Gagal membuat file temporary!"
        read -rp "Tekan Enter..."
        return 1
    }
    
    for i in "${!DNS_IPS[@]}"; do
        local ip name avg_ping
        ip=$(echo "${DNS_IPS[$i]}" | awk '{print $1}')
        name="${DNS_NAMES[$i]}"
        
        # Ping check
        avg_ping=$(ping -c 2 -W 1 "$ip" 2>/dev/null | tail -1 | awk -F '/' '{print $5}')
        [[ -z "$avg_ping" ]] && avg_ping="999"
        
        echo "$avg_ping|$name|$ip" >> "$TMP_SORT"
    done

    sort -n -t '|' -k1 "$TMP_SORT" | while IFS='|' read -r time name ip; do
        local time_display color bc_result
        if [[ "$time" == "999" ]]; then
            time_display="${RED}Down${NC}"
        else
            # Safe bc comparison with fallback
            bc_result=$(echo "$time < 30" | bc -l 2>/dev/null) || bc_result="0"
            if [[ "$bc_result" == "1" ]]; then 
                color=$GREEN
            else
                bc_result=$(echo "$time < 100" | bc -l 2>/dev/null) || bc_result="0"
                if [[ "$bc_result" == "1" ]]; then 
                    color=$YELLOW
                else 
                    color=$RED
                fi
            fi
            time_display="${color}${time} ms${NC}"
        fi
        printf "%-25s %-15s %b\n" "$name" "$ip" "$time_display"
    done
    
    rm -f "$TMP_SORT"
    TMP_SORT=""
    echo "------------------------------------------------"
    read -rp "Tekan Enter untuk kembali..."
}

apply_dns() {
    local primary="$1"
    local secondary="${2:-}"
    local name="$3"
    local auto_lock="${4:-false}"

    # --- Pre-Flight Check ---
    log_step "Cek koneksi ke $primary..."
    if ! ping -c 1 -W 2 "$primary" &> /dev/null; then
        log_error "Koneksi Gagal! Server DNS tidak merespon."
        echo "    Batalkan perubahan demi keamanan."
        sleep 2
        return $EXIT_NETWORK_ERROR
    fi

    # --- Execution ---
    log_step "Menerapkan ${name}..."
    
    init_backup # Ensure we have the original backup ONCE
    unlock_file

    # Atomic Write Strategy: Write to secure temp, then move
    local tmp_conf
    tmp_conf=$(mktemp /tmp/resolv.conf.XXXXXX) || {
        log_error "Gagal membuat file temporary!"
        sleep 2
        return 1
    }
    
    {
        echo "# Generated by xdns v${VERSION} on $(date)"
        echo "# Provider: ${name}"
        echo "nameserver $primary"
        [[ -n "$secondary" ]] && echo "nameserver $secondary"
    } > "$tmp_conf"

    # Move with force to overwrite/break symlink safely
    if ! mv -f "$tmp_conf" "$RESOLV_CONF"; then
        log_error "Gagal menulis ke $RESOLV_CONF!"
        rm -f "$tmp_conf"
        sleep 2
        return 1
    fi

    # Fix SELinux Context (Fedora/RHEL/CentOS)
    if command -v restorecon &> /dev/null; then
        restorecon "$RESOLV_CONF" 2>/dev/null || true
    fi

    log_ok "DNS Aktif!"
    flush_dns_cache
    reload_network_manager
    send_notification "DNS Changed" "Provider: $name\nPrimary: $primary"

    # Handle locking
    if [[ "$auto_lock" == "true" ]]; then
        lock_file
    else
        echo ""
        echo -e "${CYAN}Kunci DNS ini (Immutable)?${NC}"
        read -rp "Pilihan (y/n): " lock_choice
        if [[ "$lock_choice" =~ ^[Yy]$ ]]; then
            lock_file
        fi
    fi

    read -rp "Tekan Enter..."
}

set_custom_dns() {
    local c_prim c_sec
    
    log_step "Set Custom DNS"
    read -rp "Primary IP   : " c_prim
    read -rp "Secondary IP (opsional): " c_sec
    
    # Validate Primary IP (required)
    if ! validate_ipv4 "$c_prim"; then
        log_error "Primary IP tidak valid. Gunakan format: x.x.x.x (0-255)"
        sleep 2
        return
    fi
    
    # Validate Secondary IP (optional, but must be valid if provided)
    if [[ -n "$c_sec" ]] && ! validate_ipv4 "$c_sec"; then
        log_error "Secondary IP tidak valid. Gunakan format: x.x.x.x (0-255)"
        sleep 2
        return
    fi
    
    apply_dns "$c_prim" "$c_sec" "Custom DNS"
}

# ==============================================================================
# CLI ARGUMENT HANDLING
# ==============================================================================

handle_cli_set() {
    local provider_num="$1"
    local do_lock="${2:-false}"
    
    if [[ ! "$provider_num" =~ ^[1-7]$ ]]; then
        log_error "Provider number harus 1-7"
        exit $EXIT_ERROR
    fi
    
    if [[ -z "${DNS_NAMES[$provider_num]:-}" ]]; then
        log_error "Provider $provider_num tidak ditemukan"
        exit $EXIT_ERROR
    fi
    
    local ips="${DNS_IPS[$provider_num]}"
    local primary="${ips%% *}"
    local secondary="${ips#* }"
    [[ "$primary" == "$secondary" ]] && secondary=""
    
    apply_dns "$primary" "$secondary" "${DNS_NAMES[$provider_num]}" "$do_lock"
}

parse_arguments() {
    local do_lock=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -v|--version)
                show_version
                exit $EXIT_SUCCESS
                ;;
            -l|--list)
                list_providers
                exit $EXIT_SUCCESS
                ;;
            -s|--set)
                shift
                if [[ -z "${1:-}" ]]; then
                    log_error "Option -s memerlukan nomor provider (1-7)"
                    exit $EXIT_ERROR
                fi
                local provider_num="$1"
                shift
                # Check for --lock flag
                if [[ "${1:-}" == "--lock" ]]; then
                    do_lock=true
                    shift
                fi
                check_root
                check_dependencies
                handle_cli_set "$provider_num" "$do_lock"
                exit $EXIT_SUCCESS
                ;;
            -c|--custom)
                check_root
                check_dependencies
                set_custom_dns
                exit $EXIT_SUCCESS
                ;;
            -r|--restore)
                check_root
                check_dependencies
                restore_dns
                exit $EXIT_SUCCESS
                ;;
            -t|--test)
                check_root
                check_dependencies
                test_latency
                exit $EXIT_SUCCESS
                ;;
            --lock)
                do_lock=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Gunakan 'xdns --help' untuk melihat opsi yang tersedia."
                exit $EXIT_ERROR
                ;;
        esac
    done
}

# ==============================================================================
# INTERACTIVE MENU
# ==============================================================================

interactive_menu() {
    while true; do
        show_header
        get_current_dns

        echo -e "${BOLD}Pilih Provider:${NC}"
        for i in $(echo "${!DNS_NAMES[@]}" | tr ' ' '\n' | sort -n); do
            echo -e "  ${BOLD}$i.${NC} ${DNS_NAMES[$i]}"
        done
        echo ""
        echo -e "  ${BOLD}C.${NC} Custom DNS"
        echo -e "  ${BOLD}T.${NC} Speed Test"
        echo -e "  ${BOLD}R.${NC} Restore Original"
        echo -e "  ${BOLD}Q.${NC} Keluar"
        echo ""
        read -rp ">> " choice

        case "$choice" in
            [1-7])
                if [[ -n "${DNS_NAMES[$choice]:-}" ]]; then
                    local ips primary secondary
                    ips="${DNS_IPS[$choice]}"
                    primary="${ips%% *}"
                    secondary="${ips#* }"
                    [[ "$primary" == "$secondary" ]] && secondary=""
                    apply_dns "$primary" "$secondary" "${DNS_NAMES[$choice]}"
                fi
                ;;
            [cC]) set_custom_dns ;; 
            [tT]) test_latency ;; 
            [rR]) restore_dns ;; 
            [qQ]) log_ok "Bye!"; exit $EXIT_SUCCESS ;; 
            *) log_error "Invalid."; sleep 1 ;; 
        esac
    done
}

# ==============================================================================
# MAIN ENTRY POINT
# ==============================================================================

main() {
    # If arguments provided, handle CLI mode
    if [[ $# -gt 0 ]]; then
        parse_arguments "$@"
    fi
    
    # Otherwise, run interactive mode
    check_root
    check_dependencies
    init_backup
    interactive_menu
}

# Run main with all arguments
main "$@"
